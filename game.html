<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hoops Drag & Drop Challenge</title>
    <style>
        :root {
            --court-color: #e0ac69;
            --paint-color: #d35400;
            --line-color: rgba(255, 255, 255, 0.8);
            --ui-bg: rgba(0, 0, 0, 0.8);
            --text-color: #ffffff;
            --accent: #ff9f43;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #2d3436;
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* Mobile-friendly width */
            height: 100%;
            max-height: 900px;
            background: #111;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
            background-color: var(--court-color);
        }

        canvas:active {
            cursor: grabbing;
        }

        /* HUD (Heads Up Display) */
        .hud-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: none;
            z-index: 10;
        }

        .stat-box {
            text-align: center;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 2rem;
            color: var(--accent);
        }

        #timer-value {
            color: #fff;
            font-size: 2.5rem;
            font-family: monospace;
        }

        .warning {
            color: #ff4757 !important;
            animation: pulse 0.5s infinite;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
            color: white;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: var(--accent);
            text-transform: uppercase;
        }

        p {
            font-size: 1.2rem;
            color: #ccc;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.5;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background: var(--accent);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 5px 0 #c77422;
            transition: all 0.1s;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        /* Turn indicator toast */
        #toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 15;
            text-transform: uppercase;
            border: 2px solid var(--accent);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Top HUD -->
    <div class="hud-bar">
        <div class="stat-box">
            <div class="stat-label">Player 1</div>
            <div class="stat-value" id="score-p1">0</div>
        </div>

        <div class="stat-box">
            <div class="stat-label">Time</div>
            <div class="stat-value" id="timer-value">20</div>
        </div>

        <div class="stat-box">
            <div class="stat-label">Player 2</div>
            <div class="stat-value" id="score-p2">0</div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast">Player 1 Ready</div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>Buzzer Beater</h1>
        <p>1. <b>Click & Hold</b> the basketball to pick it up.<br>
           2. <b>Drag</b> it past the defenders.<br>
           3. <b>Release</b> directly over the hoop to score.</p>
        <button class="btn" onclick="game.init()">Start Match</button>
    </div>

    <!-- Game Over Screen -->
    <div id="end-screen" class="screen hidden">
        <h1>Final Score</h1>
        <h2 id="winner-text" style="margin-bottom: 20px; font-size: 2rem;">Player 1 Wins!</h2>
        <div style="display: flex; gap: 40px; margin-bottom: 30px;">
            <div>
                <div style="color:#aaa; font-size:0.8rem">PLAYER 1</div>
                <div id="final-p1" style="font-size:3rem; color:var(--accent)">0</div>
            </div>
            <div>
                <div style="color:#aaa; font-size:0.8rem">PLAYER 2</div>
                <div id="final-p2" style="font-size:3rem; color:var(--accent)">0</div>
            </div>
        </div>
        <button class="btn" onclick="game.init()">Rematch</button>
    </div>
</div>

<script>
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Dimensions
        this.width = this.canvas.clientWidth;
        this.height = this.canvas.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        // State
        this.state = 'MENU'; // MENU, PLAYING, TRANSITION, END
        this.players = [
            { id: 1, score: 0, color: '#3498db' },
            { id: 2, score: 0, color: '#e74c3c' }
        ];
        this.currentPlayerIdx = 0;
        this.round = 1;
        this.totalRounds = 2;
        
        // Timer
        this.maxTime = 10; // Reduced from 20 to 10 seconds
        this.currentTime = 10;

        // Entities
        this.ball = {
            x: this.width / 2,
            y: this.height - 50, // Start even lower for full court feel
            radius: 20,
            isHeld: false,
            homeX: this.width / 2,
            homeY: this.height - 50
        };

        this.hoop = {
            x: this.width / 2,
            y: 60, // Higher up
            radius: 35
        };

        this.defenders = [];
        this.confetti = [];

        // Input
        this.input = { x: 0, y: 0, isDown: false };

        // Bindings
        this.resize = this.resize.bind(this);
        this.loop = this.loop.bind(this);
        
        // Listeners
        window.addEventListener('resize', this.resize);
        
        // Mouse
        this.canvas.addEventListener('mousedown', e => this.handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => this.handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => this.handleEnd());
        
        // Touch
        this.canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            this.handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        window.addEventListener('touchmove', e => {
            // e.preventDefault(); // allow browser to handle some gestures? No, game needs control
            this.handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        window.addEventListener('touchend', () => this.handleEnd());

        this.lastTime = 0;
        requestAnimationFrame(this.loop);
    }

    resize() {
        const container = document.getElementById('game-container');
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        // Recenter entities if resizing during game
        this.ball.homeX = this.width / 2;
        this.ball.homeY = this.height - 50;
        this.hoop.x = this.width / 2;
        
        if (!this.ball.isHeld) {
            this.ball.x = this.ball.homeX;
            this.ball.y = this.ball.homeY;
        }
    }

    init() {
        this.players[0].score = 0;
        this.players[1].score = 0;
        this.currentPlayerIdx = 0;
        this.round = 1;
        this.updateHUD();
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('end-screen').classList.add('hidden');
        
        this.startTurn();
    }

    startTurn() {
        this.state = 'TRANSITION';
        this.ball.isHeld = false;
        this.resetBall();
        this.generateDefenders();
        
        // Toast
        const toast = document.getElementById('toast');
        toast.innerText = `Player ${this.players[this.currentPlayerIdx].id} - Round ${this.round}`;
        toast.style.borderColor = this.players[this.currentPlayerIdx].color;
        toast.style.opacity = 1;

        setTimeout(() => {
            toast.style.opacity = 0;
            this.state = 'PLAYING';
            this.currentTime = this.maxTime;
        }, 1500);
    }

    resetBall() {
        this.ball.x = this.ball.homeX;
        this.ball.y = this.ball.homeY;
        this.ball.isHeld = false;
        this.canvas.style.cursor = 'grab';
    }

    generateDefenders() {
        this.defenders = [];
        // More rows for full court density
        const numDefenders = 5; 
        const startY = 200;
        const availableHeight = this.height - 350; // Leave room at top and bottom

        for (let i = 0; i < numDefenders; i++) {
            // Random start position within bounds
            const startX = 50 + Math.random() * (this.width - 100);
            const randY = startY + (Math.random() * availableHeight);

            this.defenders.push({
                x: startX,
                y: randY,
                w: 40,
                h: 60,
                // Initial random 2D velocity
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                changeTimer: Math.random() * 60, // Time until next movement change
                color: i % 2 === 0 ? '#d63031' : '#0984e3',
                skinColor: '#f1c40f',
                animOffset: Math.random() * 10
            });
        }
    }

    handleStart(clientX, clientY) {
        if (this.state !== 'PLAYING') return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // Hit test ball (generous radius)
        const dist = Math.hypot(x - this.ball.x, y - this.ball.y);
        if (dist < this.ball.radius * 2.5) {
            this.ball.isHeld = true;
            this.canvas.style.cursor = 'grabbing';
            this.input.x = x;
            this.input.y = y;
        }
    }

    handleMove(clientX, clientY) {
        if (!this.ball.isHeld) return;
        
        const rect = this.canvas.getBoundingClientRect();
        this.input.x = clientX - rect.left;
        this.input.y = clientY - rect.top;
    }

    handleEnd() {
        if (!this.ball.isHeld) return;
        
        this.ball.isHeld = false;
        this.canvas.style.cursor = 'grab';

        // Check for score on RELEASE
        const dist = Math.hypot(this.ball.x - this.hoop.x, this.ball.y - this.hoop.y);
        
        if (dist < this.hoop.radius) {
            this.scoreBasket();
        } else {
            // Missed - return to start
            this.resetBall();
        }
    }

    scoreBasket() {
        // Calculate Score based on speed
        const bonus = Math.floor(this.currentTime * 10);
        this.players[this.currentPlayerIdx].score += (100 + bonus);
        this.updateHUD();
        
        // Effects
        this.spawnConfetti(this.hoop.x, this.hoop.y);
        
        // End turn logic
        this.state = 'TRANSITION';
        
        setTimeout(() => {
            this.nextTurn();
        }, 1000);
    }

    nextTurn() {
        this.currentPlayerIdx++;
        if (this.currentPlayerIdx >= this.players.length) {
            this.currentPlayerIdx = 0;
            this.round++;
        }

        if (this.round > this.totalRounds) {
            this.endGame();
        } else {
            this.startTurn();
        }
    }

    endGame() {
        this.state = 'END';
        document.getElementById('end-screen').classList.remove('hidden');
        document.getElementById('final-p1').innerText = this.players[0].score;
        document.getElementById('final-p2').innerText = this.players[1].score;
        
        const winnerTxt = document.getElementById('winner-text');
        if (this.players[0].score > this.players[1].score) {
            winnerTxt.innerText = "Player 1 Wins!";
            winnerTxt.style.color = this.players[0].color;
        } else if (this.players[1].score > this.players[0].score) {
            winnerTxt.innerText = "Player 2 Wins!";
            winnerTxt.style.color = this.players[1].color;
        } else {
            winnerTxt.innerText = "Draw!";
            winnerTxt.style.color = "#fff";
        }
    }

    updateHUD() {
        document.getElementById('score-p1').innerText = this.players[0].score;
        document.getElementById('score-p2').innerText = this.players[1].score;
    }

    spawnConfetti(x, y) {
        for (let i = 0; i < 30; i++) {
            this.confetti.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: `hsl(${Math.random()*360}, 100%, 50%)`
            });
        }
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();
        
        requestAnimationFrame(this.loop);
    }

    update(dt) {
        if (this.state === 'PLAYING') {
            // Timer
            this.currentTime -= dt;
            const timerEl = document.getElementById('timer-value');
            if (timerEl) {
                timerEl.innerText = Math.ceil(this.currentTime);
                if (this.currentTime < 5) timerEl.classList.add('warning');
                else timerEl.classList.remove('warning');
            }

            if (this.currentTime <= 0) {
                this.currentTime = 0;
                // Time over - 0 points for this round
                this.state = 'TRANSITION';
                setTimeout(() => this.nextTurn(), 1000);
            }

            // Ball Movement
            if (this.ball.isHeld) {
                // Smooth follow (Lerp)
                this.ball.x += (this.input.x - this.ball.x) * 0.25;
                this.ball.y += (this.input.y - this.ball.y) * 0.25;
            } else {
                // Return to home if not held (Lerp)
                this.ball.x += (this.ball.homeX - this.ball.x) * 0.1;
                this.ball.y += (this.ball.homeY - this.ball.y) * 0.1;
            }

            // Defenders
            this.defenders.forEach(def => {
                // Random Movement Logic
                def.changeTimer--;
                if (def.changeTimer <= 0) {
                    // Pick a new random angle and speed
                    const angle = Math.random() * Math.PI * 2;
                    // Speed increases with difficulty
                    const speed = (2 + (this.round * 0.5)) + (Math.random() * 3);
                    
                    def.vx = Math.cos(angle) * speed;
                    def.vy = Math.sin(angle) * speed;
                    
                    // Reset timer
                    def.changeTimer = 30 + Math.random() * 60;
                }

                def.x += def.vx;
                def.y += def.vy;

                // Wall Bouncing (X Axis)
                if (def.x < def.w/2) {
                    def.x = def.w/2;
                    def.vx *= -1;
                } else if (def.x > this.width - def.w/2) {
                    def.x = this.width - def.w/2;
                    def.vx *= -1;
                }

                // Wall Bouncing (Y Axis) - Keep inside court area
                const topBound = 120; // Below hoop
                const bottomBound = this.height - 150; // Above spawn area
                
                if (def.y < topBound) {
                    def.y = topBound;
                    def.vy *= -1;
                } else if (def.y > bottomBound) {
                    def.y = bottomBound;
                    def.vy *= -1;
                }

                // Collision Detection (Box vs Circle)
                // Simplified to distance check for gameplay feel
                if (this.ball.isHeld) {
                    const distX = Math.abs(this.ball.x - def.x);
                    const distY = Math.abs(this.ball.y - def.y);
                    
                    if (distX < (def.w/2 + this.ball.radius) && distY < (def.h/2 + this.ball.radius)) {
                        // Hit Defender
                        this.ball.isHeld = false;
                        this.resetBall();
                        // Optional penalty?
                    }
                }
            });
        }

        // Confetti
        for (let i = this.confetti.length - 1; i >= 0; i--) {
            const p = this.confetti[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2; // Gravity
            p.life -= 0.02;
            if (p.life <= 0) this.confetti.splice(i, 1);
        }
    }

    draw() {
        // Clear Background
        this.ctx.fillStyle = '#2d3436';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Draw Court
        this.drawCourt();

        // Draw Defenders (Humanoid)
        this.defenders.forEach(def => {
            // Shadow
            this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
            this.ctx.beginPath();
            this.ctx.ellipse(def.x, def.y + 25, 20, 8, 0, 0, Math.PI*2);
            this.ctx.fill();

            // Arms (Waving effect)
            const armWave = Math.sin((Date.now() / 100) + def.animOffset) * 10;
            
            this.ctx.strokeStyle = def.skinColor;
            this.ctx.lineWidth = 8;
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            // Left Arm
            this.ctx.moveTo(def.x - 15, def.y - 10);
            this.ctx.lineTo(def.x - 35, def.y + armWave);
            // Right Arm
            this.ctx.moveTo(def.x + 15, def.y - 10);
            this.ctx.lineTo(def.x + 35, def.y - armWave);
            this.ctx.stroke();

            // Legs
            this.ctx.strokeStyle = '#333'; // Tights/Legs
            this.ctx.beginPath();
            this.ctx.moveTo(def.x - 10, def.y + 20);
            this.ctx.lineTo(def.x - 15, def.y + 40); // L Leg
            this.ctx.moveTo(def.x + 10, def.y + 20);
            this.ctx.lineTo(def.x + 15, def.y + 40); // R Leg
            this.ctx.stroke();

            // Jersey Body
            this.ctx.fillStyle = def.color;
            this.ctx.fillRect(def.x - 20, def.y - 20, 40, 45);
            
            // Shorts
            this.ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Darker shade for shorts
            this.ctx.fillRect(def.x - 20, def.y + 15, 40, 15);

            // Head
            this.ctx.fillStyle = def.skinColor;
            this.ctx.beginPath();
            this.ctx.arc(def.x, def.y - 30, 12, 0, Math.PI*2);
            this.ctx.fill();

            // Headband/Hair (team color)
            this.ctx.fillStyle = def.color;
            this.ctx.beginPath();
            this.ctx.arc(def.x, def.y - 34, 12, Math.PI, 0);
            this.ctx.fill();
        });

        // Draw Hoop (Back Layer)
        this.ctx.fillStyle = '#ecf0f1'; // Backboard
        this.ctx.fillRect(this.hoop.x - 40, this.hoop.y - 40, 80, 5);

        // Draw Net
        this.ctx.beginPath();
        this.ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        this.ctx.lineWidth = 1;
        for(let i=0; i<=6; i++) {
            this.ctx.moveTo(this.hoop.x - 30 + (i*10), this.hoop.y);
            this.ctx.lineTo(this.hoop.x - 15 + (i*5), this.hoop.y + 40);
        }
        this.ctx.stroke();

        // Draw Rim
        this.ctx.beginPath();
        this.ctx.strokeStyle = '#e74c3c';
        this.ctx.lineWidth = 4;
        this.ctx.arc(this.hoop.x, this.hoop.y, this.hoop.radius, 0, Math.PI*2);
        this.ctx.stroke();

        // Draw Ball
        this.ctx.shadowColor = 'rgba(0,0,0,0.4)';
        this.ctx.shadowBlur = this.ball.isHeld ? 20 : 5;
        this.ctx.shadowOffsetY = this.ball.isHeld ? 20 : 5;
        
        // Ball Body
        this.ctx.fillStyle = '#e67e22';
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI*2);
        this.ctx.fill();

        // Ball Lines
        this.ctx.shadowColor = 'transparent'; // Reset shadow for lines
        this.ctx.strokeStyle = '#2c3e50';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(this.ball.x, this.ball.y - this.ball.radius);
        this.ctx.lineTo(this.ball.x, this.ball.y + this.ball.radius);
        this.ctx.moveTo(this.ball.x - this.ball.radius, this.ball.y);
        this.ctx.lineTo(this.ball.x + this.ball.radius, this.ball.y);
        this.ctx.stroke();

        // Highlight
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x - 5, this.ball.y - 5, 8, 0, Math.PI*2);
        this.ctx.fill();

        // Confetti
        this.confetti.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life;
            this.ctx.fillRect(p.x, p.y, 6, 6);
            this.ctx.globalAlpha = 1.0;
        });
    }

    drawCourt() {
        // Floor
        const grad = this.ctx.createLinearGradient(0,0,0,this.height);
        grad.addColorStop(0, '#d89e6d');
        grad.addColorStop(1, '#c58e57');
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0,0,this.width, this.height);

        // Lines
        this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        this.ctx.lineWidth = 4;

        // --- TOP HALF (Offensive) ---
        // Key
        this.ctx.strokeRect(this.width/2 - 70, -10, 140, 200);
        
        // Free throw circle (top of key)
        this.ctx.beginPath();
        this.ctx.arc(this.width/2, 190, 70, 0, Math.PI, false);
        this.ctx.stroke();

        // 3 Point Line
        this.ctx.beginPath();
        this.ctx.arc(this.width/2, 60, 300, 0, Math.PI, false);
        this.ctx.stroke();

        // --- MID COURT ---
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.height/2);
        this.ctx.lineTo(this.width, this.height/2);
        this.ctx.stroke();

        // Center Circle
        this.ctx.beginPath();
        this.ctx.arc(this.width/2, this.height/2, 60, 0, Math.PI*2);
        this.ctx.stroke();
        
        // Center Small Circle
        this.ctx.beginPath();
        this.ctx.arc(this.width/2, this.height/2, 15, 0, Math.PI*2);
        this.ctx.fill();

        // --- BOTTOM HALF (Start) ---
        // Just the 3-point line hint at the bottom to show it's the other side
        this.ctx.beginPath();
        this.ctx.arc(this.width/2, this.height - 60, 300, Math.PI, 0, false);
        this.ctx.stroke();
    }
}

const game = new Game();
</script>
</body>
</html>